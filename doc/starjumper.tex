\documentclass{llncs}
\usepackage{float}

\hyphenation{ btGhost-Object }

\begin{document}

\title{Starjumper}
\author{Robert Strobl, Johannes Albrecht, Tim Berning, Stefan H\"artel}
\institute{Hasso-Plattner-Institut, Prof.-Dr.-Helmert-Str. 2-3, 14482 Potsdam}

\maketitle

\section{Einleitung}

\subsection{Spielprinzip}
Starjumper ist ein Renn- und Geschicklichkeitsspiel, bei dem der Spieler mit einem
Raumschiff \"uber eine hindernisreiche Strecke mit diversen Abgr\"unden fahren und
schlussendlich sicher ins Ziel gelangen muss.\\
Dabei besitzen die Fl\"achen der Streckenabschnitte unterschiedliche Eigenschaften,
die sich auf das Fahrverhalten des Raumschiffs auswirken k\"onnen, z.B. Abbremsen
des Spielers.\\
Die Steuerung umfasst Beschleunigen, Bremsen, Lenken nach links oder rechts und
Springen.

\subsection{Spielidee}
Vorlage f\"ur unser Spiel war der Spieleklassiker Skyroads aus dem Jahr 1993, welches
von Bluemoon entwickelt wurde und wiederum selbst eine Neuauflage des Spiels Kosmonaut
aus dem eigenen Hause darstellte.\\
Das Spielprinzip wurde f\"ur Starjumper gr\"o\ss tenteils \"ubernommen.


\section{Steuerung}
Die Steuerung des Raumschiffs erfolgt sehr intuitiv, der Spieler kann beschleunigen,
bremsen, lenken und springen. Die folgende Tabelle zeigt die in-game Tastaturbelegung:

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			Beschleunigen & Pfeiltaste oben \\
			\hline
			Bremsen & Pfeiltaste unten \\
			\hline
			Links & Pfeiltaste links \\
			\hline
			Rechts & Pfeiltaste rechts \\
			\hline
			Springen & Leertaste \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Tastaturbelegung}
\end{table}
\noindent Dar\"uber hinaus kann per \texttt{Escape} jederzeit aus dem Spiel in das Men\"u
bzw. in die jeweils n\"achsth\"ohere Ebene in der Men\"uhierarchie gewechselt werden. Im
Hauptmen\"u beendet ein Druck auf \texttt{Escape} das Programm.\\
Die Navigation in den Men\"us erfolgt mithilfe der Maus.


\section{Architektur}

\textit{Die Beschreibung der Architektur erfolgt in kleineren logischen Einheiten, eine Gesamt\"ubersicht
aller verwendeten Klassen und ihrer Verbindungen untereinander findet sich im Anhang.}\\
Im Folgenden sollen nun die wichtigsten architektonischen Bestandteile von Starjumper
erl\"autert werden. 

\subsection{GameManager}
Der \texttt{GameManager} bildet die oberste Instanz des Spiels. Er verwaltet prim\"ar den \texttt{Viewer}, der f\"ur das
Rendering des Szenengraphen verantwortlich ist, sowie die Szenengraphen (in Form von \texttt{RenderingInstance}
Objekten), zwischen denen er dynamisch umschalten kann. Die Klasse \texttt{RenderingInstance} ist ein
Wrapper f\"ur Szenengraphen und dient als abstrakte Oberklasse f\"ur u.a. \texttt{Game} und \texttt{Menu}, die
sp\"ater erl\"autert werden.\\
Dar\"uber hinaus implementiert der \texttt{GameManager} \"ubergeordnete Spiellogik wie das Starten des Spiels,
Beenden, Erstellen und Aufrufen von Men\"us, sowie die Bereitstellung von Callback-Funktionen f\"ur
die Men\"us. Ein \"ubergeordneter Keyboardhandler sorgt f\"ur die globale Logik der Escape Taste.

\subsection{Menu}
Die Aufgabe der Klasse \texttt{Menu} ist das Erstellen eines Men\"us mit klickbaren Textelementen. Diese
werden als Callback auf entsprechende Methoden des \texttt{GameManagers} gemappt. Zur Anzeige der Men\"ueintr\"age
kommt das Modul osgWidget zum Einsatz.

\subsection{Game}
Die von \texttt{RenderingInstance} erbende Klasse \texttt{Game} beinhaltet die zentrale Spiellogik. Von hier aus werden die
f\"ur das Spiel ben\"otigten Elemente wie etwa \texttt{HeadUpDisplay}, \texttt{Player} und \texttt{Level} erzeugt und verwaltet,
sowie der schlu\ss endlich zu rendernde Szenengraph generiert.\\
Neben den f\"ur OpenSceneGraph wichtigen Komponenten verwaltet \texttt{Game} auch die Bullet Physics World und sorgt
f\"ur das OSG-synchrone Stepping derselben mittels eines NodeCallbacks namens \texttt{WorldUpdater}.

\subsection{Level}
Starjumper verwendet ein einfaches XML-Format f\"ur die Beschreibung der Levels. F\"ur das Parsen einer
solchen Leveldatei und dem anschlie\ss enden Umwandeln in OSG-kompatible Form zeichnet \texttt{Level} verantwortlich.\\
Derzeit m\"ogliche Elemente eines Levels sind Quader, Tunnel und das Ziel, ensprechend erzeugt \texttt{Level}
jeweils eine Instanz der Klasse \texttt{Cuboid}, \texttt{Tunnel} oder \texttt{Goal} und f\"ugt sie in einer osg::Group zusammen.\\
Diese Elementklassen wiederum generieren jeweils eine Repr\"asentation f\"ur OSG und Bullet.

\subsection{Player}
\texttt{Player} stellt die vom Benutzer steuerbare Entit\"at dar in Form eines Raumschiffs, das fix aus einer Datei
geladen wird. Zwecks Positionierbarkeit wird das Model in einer PositionAttitudeTransform gekapselt.
Neben dem Laden dieser Modeldatei werden in \texttt{Player} die Physikkomponenten f\"ur den Spieler generiert.
Die Interaktion des Benutzers mit dem Spiel erfolgt \"uber die Komponenten \texttt{PlayerState} und \texttt{PlayerUpdater},
die im n\"achsten Abschnitt n\"aher erl\"autert werden.\\
\textit{Details zu der Kombination aus \texttt{KinematicCharacterController} und \texttt{btGhostObject} finden sich im Abschnitt "Designentscheidungen".}

\subsection{PlayerUpdater}
Der \texttt{PlayerUpdater} als NodeCallback nutzt den \texttt{PlayerState}, um pro Step die neue Position des Players
zu berechnen. Genauer wird diese aus der Physics Worlds extrahiert, die die Bewegung des Spielers simuliert und so
eventuelle Kollisionen erkennen kann. Gleichzeitig werden diese Parameter aktualisiert, dies geschieht auf Basis von
Anfragen, die der Benutzer \"uber einen Tastendruck absetzt und die im \texttt{PlayerState} vermerkt werden.\\
Folgendes Sequenzdiagramm soll das Vorgehen des \texttt{PlayerUpdater}s veranschaulichen:

\section{Designentscheidungen}

\subsection{GameManager}
Wie im Abschnitt Architektur bereits erw\"ahnt 


\subsection{GameManager}


\section{Design Patterns}



\section{Diskussion und Ausblick}



% appendix section
\newpage
\appendix

\section{Vollst\"andiges Klassendiagramm}

\end{document}