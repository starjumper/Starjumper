\documentclass{llncs}
\usepackage[ngerman]{babel}
\usepackage{float}

\begin{document}

\title{Starjumper}
\author{Robert Strobl, Johannes Albrecht, Tim Berning, Stefan H\"artel}
\institute{Hasso-Plattner-Institut, Prof.-Dr.-Helmert-Str. 2-3, 14482 Potsdam}

\maketitle

\section{Einleitung}

\subsection{Spielprinzip}
Starjumper ist ein Renn- und Geschicklichkeitsspiel, bei dem der Spieler mit einem
Raumschiff \"uber eine hindernisreiche Strecke mit diversen Abgr\"unden fahren und
schlussendlich sicher ins Ziel gelangen muss.\\
Dabei besitzen die Fl\"achen der Streckenabschnitte unterschiedliche Eigenschaften,
die sich auf das Fahrverhalten des Raumschiffs auswirken k\"onnen, z.B. Abbremsen
des Spielers.\\
Die Steuerung umfasst Beschleunigen, Bremsen, Lenken nach links oder rechts und
Springen.

\subsection{Spielidee}
Vorlage f\"ur unser Spiel war der Spieleklassiker Skyroads aus dem Jahr 1993, welches
von Bluemoon entwickelt wurde und wiederum selbst eine Neuauflage des Spiels Kosmonaut
aus dem eigenen Hause darstellte.\\
Das Spielprinzip wurde f\"ur Starjumper gr\"o\ss tenteils \"ubernommen.


\section{Steuerung}
Die Steuerung des Raumschiffs erfolgt sehr intuitiv, der Spieler kann beschleunigen,
bremsen, lenken und springen. Die folgende Tabelle zeigt die in-game Tastaturbelegung:

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			Beschleunigen & Pfeiltaste oben \\
			\hline
			Bremsen & Pfeiltaste unten \\
			\hline
			Links & Pfeiltaste links \\
			\hline
			Rechts & Pfeiltaste rechts \\
			\hline
			Springen & Leertaste \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Tastaturbelegung}
\end{table}
\noindent Dar\"uber hinaus kann per \textbf{Escape} jederzeit aus dem Spiel in das Men\"u
bzw. in die jeweils n\"achsth\"ohere Ebene in der Men\"uhierarchie gewechselt werden. Im
Hauptmen\"u beendet ein Druck auf \textbf{Escape} das Programm.\\
Die Navigation in den Men\"us erfolgt mithilfe der Maus.


\section{Architektur}

\textit{Die Beschreibung der Architektur erfolgt in kleineren logischen Einheiten, eine Gesamt\"ubersicht
aller verwendeten Klassen und ihrer Verbindungen untereinander findet sich im Anhang.}\\
Im Folgenden sollen nun die wichtigsten architektonischen Bestandteile von Starjumper
erl\"autert werden. 

\subsection{GameManager}
Der \textbf{GameManager} bildet die oberste Instanz des Spiels. Er verwaltet prim\"ar den \textbf{Viewer}, der f\"ur das
Rendering des Szenengraphen verantwortlich ist, sowie die Szenengraphen (in Form von \textbf{RenderingInstance}
Objekten), zwischen denen er dynamisch umschalten kann. Die Klasse \textbf{RenderingInstance} ist ein
Wrapper f\"ur Szenengraphen und dient als abstrakte Oberklasse f\"ur u.a. \textbf{Game} und \textbf{Menu}, die
sp\"ater erl\"autert werden.\\
Dar\"uber hinaus implementiert der \textbf{GameManager} \"ubergeordnete Spiellogik wie das Starten des Spiels,
Beenden, Erstellen und Aufrufen von Men\"us, sowie die Bereitstellung von Callback-Funktionen f\"ur
die Men\"us. Ein \"ubergeordneter Keyboardhandler sorgt f\"ur die globale Logik der Escape Taste.

\subsection{Menu}
Die Aufgabe der Klasse \textbf{Menu} ist das Erstellen eines Men\"us mit klickbaren Textelementen. Diese
werden als Callback auf entsprechende Methoden des \textbf{GameManagers} gemappt. Zur Anzeige der Men\"ueintr\"age
kommt das Modul osgWidget zum Einsatz.

\subsection{Game}
Die von \textbf{RenderingInstance} erbende Klasse \textbf{Game} beinhaltet die zentrale Spiellogik. Von hier aus werden die
f\"ur das Spiel ben\"otigten Elemente wie etwa \textbf{HeadUpDisplay}, \textbf{Player} und \textbf{Level} erzeugt und verwaltet,
sowie der schlu\ss endlich zu rendernde Szenengraph generiert.\\
Neben den f\"ur OpenSceneGraph wichtigen Komponenten verwaltet \textbf{Game} auch die Bullet Physics World und sorgt
f\"ur das OSG-synchrone Stepping derselben mittels eines NodeCallbacks namens \textbf{WorldUpdater}.

\subsection{Level}
Starjumper verwendet ein einfaches XML-Format f\"ur die Beschreibung der Levels. F\"ur das Parsen einer
solchen Leveldatei und dem anschlie\ss enden Umwandeln in OSG-kompatible Form zeichnet \textbf{Level} verantwortlich.\\
Derzeit m\"ogliche Elemente eines Levels sind Quader, Tunnel und das Ziel, ensprechend erzeugt \textbf{Level}
jeweils eine Instanz der Klasse \textbf{Cuboid}, \textbf{Tunnel} oder \textbf{Goal} und f\"ugt sie in einer osg::Group zusammen.\\
Diese Elementklassen wiederum generieren jeweils eine Repr\"asentation f\"ur OSG und Bullet.

\subsection{Player}
\textbf{Player} stellt die vom Benutzer steuerbare Entit\"at dar in Form eines Raumschiffs, das fix aus einer Datei
geladen wird. Zwecks Positionierbarkeit wird das Model in einer PositionAttitudeTransform gekapselt.
Neben dem Laden dieser Modeldatei werden in \textbf{Player} die Physikkomponenten f\"ur den Spieler generiert.
Die Interaktion des Benutzers mit dem Spiel erfolgt \"uber die Komponenten \textbf{PlayerState} und \textbf{PlayerUpdater},
die im n\"achsten Abschnitt n\"aher erl\"autert werden.\\
\textit{Details zu \textbf{KinematicCharacterController} und \textbf{btGhostObject} in Kombination finden sich im Abschnitt "Designentscheidungen".}

\subsection{PlayerUpdater}
Der \textbf{PlayerUpdater} als NodeCallback nutzt den \textbf{PlayerState}, um pro Step die neue Position des Players
zu berechnen. Genauer wird diese aus der Physics Worlds extrahiert, die die Bewegung des Spielers simuliert und so
eventuelle Kollisionen erkennen kann. Gleichzeitig werden diese Parameter aktualisiert, dies geschieht auf Basis von
Anfragen, die der Benutzer \"uber einen Tastendruck absetzt und die im \textbf{PlayerState} vermerkt werden.\\
Folgendes Sequenzdiagramm soll das Vorgehen des \textbf{PlayerUpdater}s veranschaulichen:

\section{Designentscheidungen und Design Patterns}
Dieser Abschnitt besch\"aftigt sich mit einigen Besonderheiten der Starjumper Implementierung und erl\"autert deren
Beweggr\"unde und Vorteile gegen\"uber alternativer Implementierungsstrategien.

\subsection{Physik}
Da sich die physikalischen Effekte, die sich in Starjumper wiederfinden (sollten), auf korrekte Auswirkung der Schwerkraft
beim Sprung oder dem Verlassen einer Plattform, sowie der Erkennung von Kollisionen mit Umgebungsobjekten beschr\"anken,
stand zu Beginn die \"Uberlegung im Raum, diese von Hand zu implementieren. Schnell wurde jedoch klar, dass trotz des
an sich geringen Umfangs der Anforderungen an die Physik eine manuelle Implementierung viel Zeit kosten w\"urde, und so fiel
die Entscheidung zugunsten der Verwendung der Physikbibliothek Bullet.\\
Die von Bullet zur Verf\"ugung gestellten Klassen \texttt{btKinematicCharacterController} und \texttt{btGhostObject} boten
laut Interface genau die gew\"unschten Funktionen: Das Ghost Object agiert als Rigid Body in der Physikwelt und kennt
zu jedem Zeitpunkt alle eventuell vorhandenen Kollisionspartner, der \texttt{btKinematicCharacterController} stellt ein
Steuerungsinterface f\"ur das GhostObject zur Verf\"ugung. Aufgrund einiger weniger Unzul\"anglichkeiten musste allerdings
der Controller angepasst werden, sodass statt dem \texttt{btKinematicCharacterController} eine modifizierte Version
namens \texttt{KinematicCharacterController} Verwendung findet.\\
Das Rendering durch OpenSceneGraph und die Physik laufen parallel. So ist zu erkl\"aren, dass beispielsweise f\"ur
Streckenelemente wie \texttt{Cuboid} jeweils eine Repr\"asentation f\"ur den Szenengraphen und ein \texttt{btRigidBody}
f\"ur die Physics World existiert. Die Kommunikation zwischen diesen beiden Entit\"aten findet im \texttt{PlayerUpdater}
statt. Korrekt parametrisiert (Bewegungsrichtung, Fallgeschwindigkeit, Gravitation) berechnet der Controller bei jedem
Stepping der Physics World die neue Position des Spielers, welche anschlie\ss end durch den \texttt{PlayerUpdater}
abgefragt und auf die \texttt{PositionAttitudeTransform} des Spielermodells \"ubertragen wird. Im Gegenzug werden
durch den Benutzer per Tastendruck im \texttt{PlayerState} gesetzte Requests - wie der Wunsch nach links zu steuern -
ausgewertet und dienen als Basis f\"ur die Aktualisierung der Parameter des Controllers.

\subsection{Player}
Der \texttt{Player} bzw. sein Modell wird in jeder Levelinstanz ben\"otigt. Die im Verlauf des Spiels vorgenommenen \"Anderungen
am \texttt{Player} beschr\"anken sich jedoch auf Transformationen der umgebenden \texttt{PositionAttitudeTransform} und sind leicht reversibel,
wie am Beispiel des Reset erkennbar ist. In einer fr\"uheren Version wurde f\"ur jedes Level eine neue Instanz der Klasse
erzeugt, die logischerweise das Laden des Modells beinhaltet, was zu erheblicher Verz\"ogerung des Spielstarts f\"uhrte.\\
Auf Basis dieser Erkenntnisse wurde ein Refactoring vorgenommen und der \texttt{Player} zu einem Singleton erweitert. Das hei\ss t,
dass das Spielermodell nur noch ein einziges Mal beim Starten des Programms geladen werden muss und als global verf\"ugbare
Ressource gehandhabt wird, ein Aufruf der statischen Methode \texttt{Player::getInstance()} liefert auf Wunsch die Player-Instanz.\\
Neben dem Wegfall der Ladezeiten erm\"oglicht dies dar\"uber hinaus den globalen Zugriff auf den Zustand des Spielers,
der z.B. die an verschiedenen Stellen des Spiels ben\"otigten Eigenschaften Geschwindigkeit und Neigungswinkel enth\"alt.

\subsection{ParticleEffectFactory}
Die Erstellung von Partikeleffekten erfordert diverse Komponenten und deren Konfiguration. So ist neben einem \texttt{ParticleSystem}, das
die einzelnen Partikel \"uber die Dauer ihres Bestehens einschlie\ss lich ihrer L\"oschung verwaltet, ein entsprechender
\texttt{ParticleSystemUpdater} n\"otig - ein Callback, der das kontinuierliche Stepping des Partikelsystems \"ubernimmt. Weitere Komponenten
sind ein \texttt{Emitter}, der - bestehend aus einem \texttt{Shooter} und einem \texttt{Placer} - f\"ur die initiale Platzierung der Partikel verantwortlich
ist, und ein sogenanntes \texttt{Program}, das sich beliebig konfigurieren l\"asst und das Verhalten der Partikel steuert.\\
All diese Komponenten gilt es f\"ur jeden Partikeleffekt zu erstellen, woraus sich in h\"ochstem Ma\ss e redundanter Code erg\"abe
Um diesem entgegenzuwirken, existiert in Starjumper eine Klasse \texttt{ParticleEffectFactory}. Dem Factory Pattern folgend stellt sie Methoden
bereit, die einen durch die Klasse \texttt{ParticleEffect} gekapselten Partikeleffekt erzeugen und je nach Situation konfigurieren.\\
\texttt{ParticleEffect} implementiert eine Art "Standard"-Partikeleffekt, dessen einzelne Komponenten und sonstige Einstellungen sich
durch im Konstruktor \"ubergebene Objekte \"uberschreiben lassen. Durch diese Aufteilung wird duplizierter Code vermieden und
gleichzeitig die Verantwortung f\"ur Partikeleffekt an einem Ort konzentriert.


\section{Diskussion und Ausblick}



\end{document}